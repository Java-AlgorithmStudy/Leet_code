## 문제 설명
📌 **35. 삽입 위치 검색**
🌟 난이도: 쉬움
👍 13.9K
💬 606
🏢 회사

정렬된 고유한 정수 배열 `nums`와 대상 값 `target`이 주어집니다. 대상이 발견되면 인덱스를 반환하고, 발견되지 않으면 순서에 맞게 삽입될 인덱스를 반환합니다.

**예시 설명**

예시 1:

**입력:**
```plaintext
nums = [1,3,5,6], target = 5
```

**출력:**
```plaintext
2
```

**설명:**
대상 값 5는 인덱스 2에서 발견됩니다.

예시 2:

**입력:**
```plaintext
nums = [1,3,5,6], target = 2
```

**출력:**
```plaintext
1
```

**설명:**
대상 값 2는 배열에 존재하지 않으므로 순서에 맞게 삽입될 인덱스 1을 반환합니다.

예시 3:

**입력:**
```plaintext
nums = [1,3,5,6], target = 7
```

**출력:**
```plaintext
4
```

**설명:**
대상 값 7은 배열에 존재하지 않으므로 순서에 맞게 삽입될 인덱스 4를 반환합니다.

제약사항:

- 1 <= nums.length <= 104
- -104 <= nums[i] <= 104
- 배열 `nums`에는 오름차순으로 정렬된 고유한 값이 포함됩니다.
- -104 <= target <= 104

**문제 해결 방법**

이 문제에서는 정렬된 배열 `nums`에서 대상 값 `target`을 검색해야 합니다. 대상 값이 존재하는 경우 해당 인덱스를 반환하고, 존재하지 않는 경우 삽입될 인덱스를 반환해야 합니다.

주어진 배열이 정렬되어 있으므로 이진 검색(Binary Search) 알고리즘을 사용하여 문제를 해결할 수 있습니다. 다음은 문제를 해결하기 위한 절차입니다:

1. 이진 검색 알고리즘을 사용하여 대상 값 `target`을 배열 `nums`에서 찾습니다.
2. 대상 값이 존재하는 경우 해당 인덱스를 반환합니다.
3. 대상 값이 존재하지 않는 경우 삽입될 인덱스를 반환합니다. 이는 대상 값이 배열 `nums`에서 삽입될 위치이므로 순서에 맞는 인덱스입니다.

이러한 절차를 코드로 구현하면 다음과 같습니다:

```java
class Solution {
    public int searchInsert(int[] nums, int target) {
        int left = 0;
        int right = nums.length - 1;

        while (left <= right) {
            int mid = left + (right - left) / 2;
            if (nums[mid] == target) {
                return mid;
            } else if (nums[mid] < target) {
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }

        return left;
    }
}
```

위의 코드는 이진 검색 알고리즘을 사용하여 대상 값 `target`을 배열 `nums`에서 검색하고, 대상 값이 존재하는 경우 해당 인덱스를 반환합니다. 대상 값이 존재하지 않는 경우 삽입될 인덱스를 반환합니다.

주어진 제약사항에서 O(log n)의 시간 복잡도를 가져야 한다고 명시했으므로, 이진 검색 알고리즘을 사용하여 O(log n)의 시간 복잡도를 만족시킬 수 있습니다.

위의 코드를 사용하여 문제를 성공적으로 해결할 수 있습니다.
