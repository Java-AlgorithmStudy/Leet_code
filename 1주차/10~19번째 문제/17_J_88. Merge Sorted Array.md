## 문제 설명
📌 **88. 정렬된 배열 병합**
🌟 난이도: 쉬움
👍 11.5K
💬 1.2K
🏢 회사

두 개의 정수 배열 `nums1`과 `nums2`가 주어지며, 각 배열은 비내림차순으로 정렬되어 있습니다. 또한 `m`과 `n`은 각각 `nums1`과 `nums2`의 요소 수를 나타냅니다.

`nums1`과 `nums2`를 비내림차순으로 정렬된 하나의 배열로 병합하세요.

최종 정렬된 배열은 함수에서 반환되지 않고 대신 `nums1` 배열 내부에 저장되어야 합니다. 이를 위해 `nums1`의 길이는 `m + n`이며, 첫 `m`개 요소는 병합해야 하는 요소를 나타내고 나머지 `n`개 요소는 0으로 설정되어 무시되어야 합니다. `nums2`의 길이는 `n`입니다.

**예시 설명**

예시 1:

**입력:**
```plaintext
nums1 = [1,2,3,0,0,0], m = 3, nums2 = [2,5,6], n = 3
```

**출력:**
```plaintext
[1,2,2,3,5,6]
```

**설명:**
병합할 배열은 [1,2,3]과 [2,5,6]입니다.
병합 결과는 [1,2,2,3,5,6]이며, 밑줄로 표시된 요소는 `nums1`에서 가져온 것입니다.

예시 2:

**입력:**
```plaintext
nums1 = [1], m = 1, nums2 = [], n = 0
```

**출력:**
```plaintext
[1]
```

**설명:**
병합할 배열은 [1]과 []입니다.
병합 결과는 [1]입니다.

예시 3:

**입력:**
```plaintext
nums1 = [0], m = 0, nums2 = [1], n = 1
```

**출력:**
```plaintext
[1]
```

**설명:**
병합할 배열은 []과 [1]입니다.
병합 결과는 [1]입니다.
m = 0이므로 `nums1`에 요소가 없습니다. 0은 병합 결과가 `nums1`에 들어갈 수 있도록 포함된 것입니다.

제약사항:

- `nums1.length == m + n`
- `nums2.length == n`
- 0 <= m, n <= 200
- 1 <= m + n <= 200
- -109 <= nums1[i], nums2[j] <= 109

**추가 질문**: O(m + n) 시간 복잡도로 동작하는 알고리즘을 만들 수 있습니까?

**문제 해결 방법**

이 문제에서는 두 개의 정렬된 정수 배열을 병합하여 비내림차순으로 정렬된 하나의 배열을 생성해야 합니다.

다음은 문제를 해결하기 위한 절차입니다:

1. `nums1`과 `nums2`를 병합하기 위해 `nums1`의 뒷부분에 요소를 추가할 수 있도록 `nums1` 배열의 크기를 조정합니다.
2. `nums1`과 `nums2`의 가장 큰 요소부터 비교하고, 큰 요소를 `nums1`의 뒷부분부터 순서대로 배치합니다.
3. `nums1`과 `nums2`의 모든 요소를 비교하고 배치한 후에도 `nums2`에 남은 요소가 있다면, 해당 요소를 `nums1`의 뒷부분에 순서대로 배치합니다.
4. 최종적으로 `nums1`은 병합 결과인 비내림차순으로 정렬된 배열입니다.

이러한 절차를 코드로 구현하면 다음과 같습니다:

```java
class Solution {
    public void merge(int[] nums1, int m, int[] nums2, int n) {
        int i = m - 1;
        int j = n - 1;
        int k = m + n - 1;
        
        while (i >= 0 && j >= 0) {
            if (nums1[i] > nums2[j]) {
                nums1[k] = nums1[i];
                i--;
            } else {
                nums1[k] = nums2[j];
                j--;
            }
            k--;
        }
        
        while (j >= 0) {
            nums1[k] = nums2[j];
            j--;
            k--;
        }
    }
}
```

위의 코드는 `nums1`과 `nums2`를 비내림차순으로 병합하는 과정을 수행합니다. 두 배열의 가장 큰

 요소부터 비교하여 `nums1`의 뒷부분에 순서대로 배치합니다. 병합 후에도 `nums2`에 남은 요소가 있다면 해당 요소를 `nums1`의 뒷부분에 추가합니다.

위의 코드를 사용하여 문제를 성공적으로 해결할 수 있습니다.
