## 문제 설명
📌 **27. 원소 제거**
🌟 난이도: 쉬움
👍 559
💬 624
🏢 회사

정수 배열 `nums`와 정수 `val`이 주어집니다. `nums`에서 모든 `val`의 발생을 제거하십시오. 요소의 순서는 변경될 수 있습니다. 그런 다음 `val`과 같지 않은 요소의 수를 반환합니다.

`val`과 같지 않은 요소의 수를 `k`로 간주하고, 통과하려면 다음 작업을 수행해야 합니다:

1. `nums` 배열을 변경하여 `nums`의 처음 `k`개 요소에는 `val`과 같지 않은 요소가 포함되도록 합니다. `nums`의 나머지 요소와 `nums`의 크기는 중요하지 않습니다.
2. `k`를 반환합니다.

사용자 정의 판정기:
판정기는 다음 코드로 솔루션을 테스트합니다.

```java
int[] nums = [...]; // 입력 배열
int val = ...; // 제거할 값
int[] expectedNums = [...]; // 정답 배열의 예상 값
                            // val과 같지 않은 값들로 정렬되어 있습니다.

int k = removeElement(nums, val); // 구현한 함수 호출

assert k == expectedNums.length;
sort(nums, 0, k); // nums의 처음 k개 요소를 정렬합니다.
for (int i = 0; i < actualLength; i++) {
    assert nums[i] == expectedNums[i];
}
```

모든 단언문(assertions)이 통과하면 솔루션이 허용됩니다.

예시 1:

**입력:**
```plaintext
nums = [3,2,2,3], val = 3
```

**출력:**
```plaintext
2, nums = [2,2,_,_]
```

**설명:**
함수는 k = 2를 반환해야 하며, nums의 처음 두 요소는 각각 2입니다. 반환된 k 이후의 값은 중요하지 않습니다. (빈칸은 어떤 값이 들어있어도 상관 없습니다.)

예시 2:

**입력:**
```plaintext
nums = [0,1,2,2,3,0,4,2], val = 2
```

**출력:**
```plaintext
5, nums = [0,1,4,0,3,_,_,_]
```

**설명:**
함수는 k = 5를 반환해야 하며, nums의 처음 다섯 요소는 각각 0, 0, 1, 3, 4입니다. 반환된 k 이후의 값은 중요하지 않습니다. (빈칸은 어떤 값이 들어있어도 상관 없습니다.)

제약사항:

- 0 <= nums.length <= 100
- 0 <= nums[i] <= 50
- 0 <= val <= 100
- 
## 문제 해설

정수 배열 `nums`와 정수 `val`이 주어집니다. `nums`에서 모든 `val`의 발생을 제거하십시오. 요소의 순서는 변경될 수 있습니다. 그런 다음 `val`과 같지 않은 요소의 수를 반환합니다.

**풀이 전략**

이 문제는 배열에서 특정 값 `val`을 제거하는 문제입니다. 배열을 순회하면서 `val`과 같은 요소를 만나면 해당 요소를 제외하고, 순서를 유지하며 배열을 재구성해야 합니다. 최종적으로 `val`과 같지 않은 요소의 수를 반환해야 합니다.

**알고리즘**

1. 배열을 순회하면서 `val`과 같지 않은 요소를 찾습니다.
2. 해당 요소를 배열의 앞부분으로 이동시킵니다.
3. 중복되지 않은 요소의 수를 카운트합니다.
4. 중복되지 않은 요소의 수를 반환합니다.

자세한 풀이 방법을 다음과 같이 코드로 구현할 수 있습니다.

```java
class Solution {
    public int removeElement(int[] nums, int val) {
        int n = nums.length;
        int k = 0; // 중복되지 않은 요소의 수

        for (int i = 0; i < n; i++) {
            if (nums[i] != val) {
                nums[k] = nums[i];
                k++;
            }
        }

        return k;
    }
}
```

위의 코드는 배열을 순회하면서 `val`과 같지 않은 요소를 발견하면 해당 요소를 배열의 앞부분으로 이동시키고, 중복되지 않은 요소의 수를 카운트합니다. 이렇게 구현된 코드를 사용하여 문제를 해결할 수 있습니다.

**복잡도 분석**

- 시간 복잡도: O(n)
  - 배열을 한 번 순회하므로 O(n)의 시간이 소요됩니다.
- 공간 복잡도: O(1)
  - 추가적인 공간이 필요하지 않습니다. 입력 배열 `nums` 내에서 요소를 이동시키기 때문에 O(1)의 공간 복잡도를 갖습니다.
