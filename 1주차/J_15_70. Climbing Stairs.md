## 문제 설명
📌 **70. 계단 오르기**
🌟 난이도: 쉬움
👍 19K
💬 611
🏢 회사

당신은 계단을 오르고 있습니다. 정상에 도달하기 위해서는 n개의 계단을 오르셔야 합니다.

한 번에 1개 또는 2개의 계단을 오를 수 있습니다. 정상에 도달하기 위한 서로 다른 방법의 수는 몇 가지인지 계산하세요.

**예시 설명**

예시 1:

**입력:**
```plaintext
n = 2
```

**출력:**
```plaintext
2
```

**설명:**
정상에 도달하는 데는 두 가지 방법이 있습니다.
1. 1 계단 오르기 + 1 계단 오르기
2. 2 계단 오르기

예시 2:

**입력:**
```plaintext
n = 3
```

**출력:**
```plaintext
3
```

**설명:**
정상에 도달하는 데는 세 가지 방법이 있습니다.
1. 1 계단 오르기 + 1 계단 오르기 + 1 계단 오르기
2. 1 계단 오르기 + 2 계단 오르기
3. 2 계단 오르기 + 1 계단 오르기

제약사항:

- 1 <= n <= 45

**문제 해결 방법**

이 문제는 주어진 계단의 수 `n`을 오를 때, 서로 다른 방법의 수를 계산하는 것입니다. 한 번에 1개 또는 2개의 계단을 오를 수 있습니다.

다음은 문제를 해결하기 위한 절차입니다:

1. `n`이 1인 경우, 1개의 계단만 오를 수 있으므로 1을 반환합니다.
2. `n`이 2인 경우, 1개의 계단을 오르는 방법과 2개의 계단을 오르는 방법이 각각 1가지씩 있으므로 2를 반환합니다.
3. `n`이 3 이상인 경우, i-1번째 계단까지 오르는 방법의 수와 i-2번째 계단까지 오르는 방법의 수를 합산하여 i번째 계단까지 오르는 방법의 수를 구합니다. 즉, `dp[i] = dp[i-1] + dp[i-2]`를 반복적으로 계산합니다.
4. 마지막 계단인 `dp[n]`의 값을 반환합니다.

이러한 절차를 코드로 구현하면 다음과 같습니다:

```java
class Solution {
    public int climbStairs(int n) {
        if (n == 1) {
            return 1;
        }
        
        int[] dp = new int[n + 1];
        dp[1] = 1;
        dp[2] = 2;
        
        for (int i = 3; i <= n; i++) {
            dp[i] = dp[i - 1] + dp[i - 2];
        }
        
        return dp[n];
    }
}
```

위의 코드는 동적 계획법(Dynamic Programming)을 활용하여 계단을 오르는 방법의 수를 계산합니다. `dp` 배열을 사용하여 i번째 계단까지 오르는 방법의 수를 저장하고, 반복문을 통해 값을 계산합니다.

위의 코드를 사용하여 문제를 성공적으로 해결할 수 있습니다.
