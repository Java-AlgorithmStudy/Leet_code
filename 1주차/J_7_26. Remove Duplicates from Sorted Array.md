## 문제 설명
📌 **26. 정렬된 배열에서 중복 요소 제거**
🌟 난이도: 쉬움
👍 11.7K
💬 15.7K
🏢 회사

비감소 순서로 정렬된 정수 배열 `nums`가 주어집니다. 각 고유한 요소가 한 번씩만 나타나도록 중복을 제거하십시오. 요소의 상대적인 순서는 유지되어야 합니다. 그런 다음 `nums`에서 고유한 요소의 수를 반환합니다.

`nums`의 고유한 요소 수를 `k`로 간주하고, 통과하려면 다음 작업을 수행해야 합니다:

1. `nums` 배열을 변경하여 `nums`의 처음 `k`개 요소에는 초기 `nums`에 있던 고유한 요소가 순서대로 포함되도록 합니다. `nums`의 나머지 요소와 `nums`의 크기는 중요하지 않습니다.
2. `k`를 반환합니다.

사용자 정의 판정기:
판정기는 다음 코드로 솔루션을 테스트합니다.

```java
int[] nums = [...]; // 입력 배열
int[] expectedNums = [...]; // 정답 배열의 예상 값

int k = removeDuplicates(nums); // 구현한 함수 호출

assert k == expectedNums.length;
for (int i = 0; i < k; i++) {
    assert nums[i] == expectedNums[i];
}
```

모든 단언문(assertions)이 통과하면 솔루션이 허용됩니다.

## 예시 1:

입력: nums = [1,1,2]
출력: 2, nums = [1,2,_]
설명: 함수는 k = 2를 반환해야 하며, nums의 처음 두 요소는 각각 1과 2입니다. 반환된 k 이후의 값은 중요하지 않습니다. (빈칸은 어떤 값이 들어있어도 상관 없습니다.)

## 예시 2:

입력: nums = [0,0,1,1,1,2,2,3,3,4]
출력: 5, nums = [0,1,2,3,4,_,_,_,_,_]
설명: 함수는 k = 5를 반환해야 하며, nums의 처음 다섯 요소는 0, 1, 2, 3, 4입니다. 반환된 k 이후의 값은 중요하지 않습니다. (빈칸은 어떤 값이 들어있어도 상관 없습니다.)

## 제약사항:

- 1 <= nums.length <= 3 * 104
- -100 <= nums[i] <= 100
- nums는 비감소 순서로 정렬되어 있습니다.

## 문제 해결 방법:
이 문제에서는 비감소 순서로 정렬된 배열에서 중복 요소를 제거해야 합니다. 중복이 제거된 요소의 수를 카운트하고, 배열의 앞부분에 중복이 제거된 요소들을 순서대로 유지하면 됩니다.

다음은 문제를 해결하기 위한 절차입니다:

1. 배열을 순회하면서 중복된 요소를 제거합니다.
2. 중복된 요소를 만나면 건너뛰고, 중복되지 않은 요소를 만나면 배열의 앞부분에 순서대로 넣습니다.
3. 중복이 제거된 요소의 수를 카운트합니다.
4. 중복이 제거된 요소의 수를 반환합니다.

자세한 풀이 방법을 다음과 같이 코드로 구현할 수 있습니다.

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        int n = nums.length;
        if (n == 0) {
            return 0;
        }
        
        int k = 1;
        for (int i = 1; i < n; i++) {
            if (nums[i] != nums[i - 1]) {
                nums[k] = nums[i];
                k++;
            }
        }
        
        return k;
    }
}
```

위의 코드는 배열을 순회하면서 중복된 요소를 건너뛰고, 중복되지 않은 요소를 배열의 앞부분에 순서대로 넣습니다. 중복이 제거된 요소의 수를 카운트하고, 중복이 제거된 요소의 수를 반환합니다. 이 코드를 사용하여 문제를 성공적으로 해결했습니다.
