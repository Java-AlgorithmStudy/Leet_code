## 문제 설명
📌 **83. 정렬된 연결 리스트의 중복 제거**
🌟 난이도: 쉬움
👍 7.6K
💬 254
🏢 회사

정렬된 연결 리스트의 헤드(head)가 주어집니다. 각 요소가 한 번씩만 나타나도록 중복을 제거한 연결 리스트를 반환하세요. 또한 결과 연결 리스트는 정렬되어야 합니다.

**예시 설명**

예시 1:

**입력:**
```plaintext
head = [1,1,2]
```

**출력:**
```plaintext
[1,2]
```

**설명:**
1과 2만 포함된 연결 리스트를 반환해야 합니다.

예시 2:

**입력:**
```plaintext
head = [1,1,2,3,3]
```

**출력:**
```plaintext
[1,2,3]
```

**설명:**
1, 2, 3만 포함된 연결 리스트를 반환해야 합니다.

제약사항:

- 리스트의 노드 수는 [0, 300] 범위에 있습니다.
- -100 <= Node.val <= 100
- 리스트는 오름차순으로 정렬되어 있다는 것이 보장됩니다.

**문제 해결 방법**

이 문제에서는 정렬된 연결 리스트에서 중복된 요소를 제거하고, 정렬된 연결 리스트를 반환해야 합니다.

다음은 문제를 해결하기 위한 절차입니다:

1. 주어진 연결 리스트가 비어 있는 경우, 중복된 요소가 없으므로 그대로 반환합니다.
2. 현재 노드를 헤드(head)로 초기화하고, 다음 노드를 현재 노드의 다음 노드로 설정합니다.
3. 현재 노드와 다음 노드의 값이 같으면, 다음 노드를 다음 다음 노드로 업데이트합니다.
4. 현재 노드와 다음 노드의 값이 다르면, 다음 노드를 현재 노드로 설정하고, 다음 노드의 값을 현재 노드의 다음 노드로 업데이트합니다.
5. 3-4 단계를 연결 리스트의 끝까지 반복합니다.
6. 최종적으로 헤드 노드를 반환합니다.

이러한 절차를 코드로 구현하면 다음과 같습니다:

```java
class Solution {
    public ListNode deleteDuplicates(ListNode head) {
        if (head == null) {
            return head;
        }
        
        ListNode current = head;
        while (current.next != null) {
            if (current.val == current.next.val) {
                current.next = current.next.next;
            } else {
                current = current.next;
            }
        }
        
        return head;
    }
}
```

위의 코드는 주어진 연결 리스트에서 중복된 요소를 제거하는 과정을 반복문을 통해 수행합니다. 연결 리스트의 노드 값을 비교하고, 중복된 요소를 제거합니다.

위의 코드를 사용하여 문제를 성공적으로 해결할 수 있습니다.
