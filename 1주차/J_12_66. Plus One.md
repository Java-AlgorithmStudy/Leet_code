## 문제 설명
📌 **66. 1 더하기**
🌟 난이도: 쉬움
👍 7.7K
💬 5K
🏢 회사

정수 배열 `digits`로 표현된 큰 정수가 주어집니다. `digits[i]`는 정수의 i번째 자릿수를 나타냅니다. `digits`는 왼쪽에서 오른쪽으로 자릿수의 가장 중요한 자릿수부터 가장 덜 중요한 자릿수까지 순서대로 정렬되어 있습니다. 큰 정수는 선행 0을 포함하지 않습니다.

큰 정수에 1을 더한 후, 결과로 나오는 자릿수의 배열을 반환합니다.

**예시 설명**

예시 1:

**입력:**
```plaintext
digits = [1,2,3]
```

**출력:**
```plaintext
[1,2,4]
```

**설명:**
배열은 정수 123을 나타냅니다.
1을 더하면 123 + 1 = 124가 됩니다.
따라서 결과는 [1,2,4]가 되어야 합니다.

예시 2:

**입력:**
```plaintext
digits = [4,3,2,1]
```

**출력:**
```plaintext
[4,3,2,2]
```

**설명:**
배열은 정수 4321을 나타냅니다.
1을 더하면 4321 + 1 = 4322가 됩니다.
따라서 결과는 [4,3,2,2]가 되어야 합니다.

예시 3:

**입력:**
```plaintext
digits = [9]
```

**출력:**
```plaintext
[1,0]
```

**설명:**
배열은 정수 9를 나타냅니다.
1을 더하면 9 + 1 = 10이 됩니다.
따라서 결과는 [1,0]이 되어야 합니다.

제약사항:

- 1 <= digits.length <= 100
- 0 <= digits[i] <= 9
- `digits`는 선행 0을 포함하지 않습니다.

**문제 해결 방법**

이 문제에서는 정수 배열 `digits`로 표현된 큰 정수에 1을 더한 결과를 반환해야 합니다. `digits` 배열은 가장 중요한 자릿수부터 가장 덜 중요한 자릿수까지 순서대로 정렬되어 있습니다.

다음은 문제를 해결하기 위한 절차입니다:

1. `digits` 배열을 끝에서부터 탐색하면서 9가 아닌 첫 번째 숫자를 찾습니다.
2. 만약 9가 아닌 숫자를 찾지 못하면 배열의 맨 앞에 1을 추가하고 모든 숫자를 0으로 바꿉니다.
3. 9가 아닌 숫자를 찾으면 해당 숫자를 1 증가시키고, 그 뒤의 모든 숫자를 0으로 바꿉니다.

이러한 절차를 코드로 구현하면 다음과 같습니다:

```java
class Solution {
    public int[] plusOne(int[] digits) {
        int n = digits.length;

        // digits 배열 끝에서부터 9가 아닌 첫 번째 숫자를 찾음
        for (int i = n - 1; i >= 0; i--) {
            if (digits[i] != 9) {
                digits[i]++;
                return digits;
            }
            digits[i] = 0;
        }

        // digits 배열에 모든 숫자가 9인 경우, 맨 앞에 1을 추가하고 모든 숫자를 0으로 바꿈
        int[] result = new int[n + 1];
        result[0] = 1;
        return result;
    }
}
```

위의 코드는 `digits` 배열을 끝에서부터 탐색하면서 9가 아닌 첫 번째 숫자를 찾고, 해당 숫자를 1 증가시킵니다. 만약 9가 아닌 숫자를 찾지 못하면 배열의 맨 앞에 1을 추가하고 모든 숫자를 0으로 바꿉니다.

위의 코드를 사용하여 문제를 성공적으로 해결할 수 있습니다.
