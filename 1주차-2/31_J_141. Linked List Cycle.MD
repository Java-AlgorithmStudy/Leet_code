## 문제 설명
📌 **141. 연결 리스트 사이클 판별**
🌟 난이도: 쉬움
👍 12.9K
💬 1.1K
🏢 회사

연결 리스트의 헤드인 `head`가 주어지면, 연결 리스트에 사이클이 있는지 판별하세요.

연결 리스트에 사이클이 있는 경우, 계속해서 다음 포인터를 따라가면 어떤 노드든지 다시 도달할 수 있습니다. 내부적으로 pos는 꼬리 노드의 다음 포인터가 연결되는 노드의 인덱스를 나타냅니다. pos는 매개변수로 전달되지 않습니다.

연결 리스트에 사이클이 있는 경우 true를, 그렇지 않은 경우 false를 반환하세요.

**예시 설명**

예시 1:

**입력:**
```plaintext
head = [3,2,0,-4], pos = 1
```

**출력:**
```plaintext
true
```

설명: 연결 리스트에는 사이클이 있으며, 꼬리가 1번 노드에 연결됩니다 (0번 인덱스부터 시작).

예시 2:

**입력:**
```plaintext
head = [1,2], pos = 0
```

**출력:**
```plaintext
true
```

설명: 연결 리스트에는 사이클이 있으며, 꼬리가 0번 노드에 연결됩니다.

예시 3:

**입력:**
```plaintext
head = [1], pos = -1
```

**출력:**
```plaintext
false
```

설명: 연결 리스트에 사이클이 없습니다.

**문제 해결 방법**

연결 리스트에 사이클이 있는지 판별해야 합니다. 추가적인 메모리 사용 없이 O(1) 메모리로 해결해야 하므로, 효율적인 알고리즘을 사용해야 합니다.

연결 리스트에 사이클이 있는지 판별하기 위해 다음과 같은 방법을 사용할 수 있습니다:

1. 빠른 포인터와 느린 포인터를 사용합니다.
2. 빠른 포인터는 한 번에 2개의 노드를 이동하고, 느린 포인터는 한 번에 1개의 노드를 이동합니다.
3. 빠른 포인터와 느린 포인터가 만나면 사이클이 있음을 의미합니다.

아래는 위의 알고리즘을 구현한 예시입니다:

```java
public class Solution {
    public boolean hasCycle(ListNode head) {
        if (head == null || head.next == null) {
            return false;
        }
        
        ListNode slow = head;
        ListNode fast = head.next;
        
        while (slow != fast) {
            if (fast == null || fast.next == null) {
                return false;
            }
            
            slow = slow.next;
            fast = fast.next.next;
        }
        
        return true;
    }
}
```

위의 코드는 연결 리스트에 사이클이 있는지 판별하기 위한 `hasCycle` 함수를 구현한 예시입니다. 함수는 빠른 포인터와 느린 포인터를 초기화하고, 반복문을 사용하여 빠른 포인터와 느린 포인터가 만날 때까지 진행합니다. 만약 사이클이 없는 경우 빠른 포인터가 null에 도달하거나 null 다음 노드에 도달할 때까지 반복문을 진행합니다. 반복문이 종료된 후 빠른 포인터와 느린 포인터가 만난 경우 사이클이 있음을 의미하므로 true를 반환합니다.
